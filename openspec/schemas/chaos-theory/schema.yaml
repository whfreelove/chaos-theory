name: chaos-theory
version: 1
description: Default OpenSpec workflow - proposal → requirements/design → tasks
artifacts:
  - id: proposal
    generates: proposal.md
    description: Initial proposal document outlining the change
    template: proposal.md
    instruction: >
      Create the proposal document that establishes WHY this change is needed.

      FORBIDDEN WORDS (flag ANY use):
      - Verbs: implements, uses, supports, calls, invokes, leverages, utilizes
      - Nouns: hook, algorithm, data structure, endpoint, handler, middleware, API call

      If you find yourself using these words, you're describing HOW not WHAT.
      Reframe around user-visible artifacts and behaviors.


      Section Guidelines:

      - **Why**: State the problem in HUMAN BURDEN terms (context waste, rework,
      variability, manual effort). NOT implementation terms (missing API, no hook,
      needs refactor). Keep to 1-2 sentences - if you need more, you're leaking
      implementation detail.

      - **What Changes**: List ARTIFACTS and BEHAVIORS only. What files/plugins
      are created? What can users do that they couldn't before? Avoid describing
      mechanisms. Mark breaking changes with **BREAKING**.

      - **Capabilities**: Group by ACTOR/ROLE, not by feature:
        - Format: `<actor> can <outcome>` (e.g., "Skill authors can ship complete task workflows")
        - **New Capabilities**: Each becomes `requirements/<name>/requirements.feature.md`. Use kebab-case.
        - **Modified Capabilities**: Only if spec-level REQUIREMENTS change. Check `openspec/requirements/` for existing names.

      - **Impact**: Describe USER INTERACTION changes, not technical footprint.
      Who benefits and how? Not "adds 3 files" but "users get ready-to-execute checklists."

      - **Non-Goals** (optional): Explicitly scope what this change does NOT address.


      SELF-CHECK before finalizing:
      1. Does "Why" mention human cost (not technical gaps)?
      2. Does "What Changes" avoid forbidden verbs/nouns?
      3. Are Capabilities grouped by actor (not feature/component)?
      4. Does Impact describe experience changes (not architecture)?
      5. Is it under 1 page? (Brevity forces abstraction)


      IMPORTANT: The Capabilities section creates the contract between proposal
      and requirements phases. Research existing requirements (if any exist) before filling this in.


      This is the foundation - requirements, design, and tasks all build on this.
    requires: []
  - id: requirements
    generates: requirements/**/*.md
    description: Detailed behavioral specifications for the change
    template: requirements.feature.md
    instruction: >
      Create requirement specification files using MDG (Markdown-Gherkin) format.

      Invoke skill: `tokamak:writing-markdown-gherkin` for full MDG reference.


      TERMINOLOGY (proposal language → Gherkin keyword):

      - "Capability" → "Feature" (one Feature per capability file)

      - "Requirement" → "Rule" (requirements are Rules under Features)


      Create one requirements file per capability listed in the proposal:

      - New capabilities: `requirements/<capability-slug>/requirements.feature.md`

      - Modified capabilities: use existing folder name from `openspec/specs/<capability>/`


      DELTA STRUCTURE (top-level headers):

      - `# ADDED Requirements` - contains full MDG content (Feature/Rule/Scenario)

      - `# MODIFIED Requirements` - contains full updated MDG content

      - `# REMOVED Requirements` - contains ID list with reasons only

      - `# RENAMED Requirements` - contains ID mapping with reasons only


      MDG HIERARCHY (shifted down under delta headers):

      ```
      # ADDED Requirements

      `@<slug>`
      ## Feature: <capability name>

      `@<slug>:1`
      ### Rule: <business rule>

      #### Background
      - Given <common precondition>

      `@<slug>:1.1`
      #### Scenario: <behavior title>
      - Given <state>
      - When <action>
      - Then <outcome>
      ```


      TAGGING CONVENTION:

      - Feature: `@<slug>` (kebab-case capability name)

      - Rule: `@<slug>:Y` (Y = rule number)

      - Scenario: `@<slug>:Y.Z` (Z = scenario number within rule)


      MODIFIED requirements workflow:

      1. Locate existing requirement in `openspec/specs/<capability>/requirements.feature.md`

      2. Copy the ENTIRE Feature/Rule/Scenario block

      3. Paste under `# MODIFIED Requirements` and edit

      4. Ensure tags match exactly for diff tracking


      REMOVED/RENAMED format (ID lists only, no MDG content):

      ```
      # REMOVED Requirements

      - `@<slug>:Y`
        - **Reason**: <why removed>

      # RENAMED Requirements

      - `@<old-slug>:Y` → `@<new-slug>:Y`
        - **Reason**: <why renamed>
      ```


      SELF-CHECK before finalizing:

      1. Does each file have exactly one Feature (= one capability)?

      2. Is each scenario testable (observable behavior, not internal state)?

      3. Do all tags follow the `@slug:Y.Z` convention?

      4. Are ADDED/MODIFIED sections MDG content, REMOVED/RENAMED just ID lists?
    requires:
      - proposal
  - id: design
    generates: design.md
    description: Technical design document with implementation details
    template: design.md
    instruction: >
      Create the design document that explains HOW to implement the change.


      When to include design.md (create only if any apply):

      - Cross-cutting change (multiple services/modules) or new architectural
      pattern

      - New external dependency or significant data model changes

      - Security, performance, or migration complexity

      - Ambiguity that benefits from technical decisions before coding


      Sections:

      - **Context**: Background, current state, constraints, stakeholders

      - **Goals / Non-Goals**: What this design achieves and explicitly excludes

      - **Decisions**: Key technical choices with rationale (why X over Y?).
      Include alternatives considered for each decision.

      - **Risks / Trade-offs**: Known limitations, things that could go wrong.
      Format: [Risk] → Mitigation

      - **Migration Plan**: Steps to deploy, rollback strategy (if applicable)

      - **Open Questions**: Outstanding decisions or unknowns to resolve


      Focus on architecture and approach, not line-by-line implementation.

      Reference the proposal for motivation and specs for requirements.


      Good design docs explain the "why" behind technical decisions.
    requires:
      - proposal
  - id: tasks
    generates: tasks.md
    description: Implementation checklist with trackable tasks
    template: tasks.md
    instruction: >
      Create the task list that breaks down the implementation work.


      **IMPORTANT: Follow the template below exactly.** The apply phase parses

      checkbox format to track progress. Tasks not using `- [ ]` won't be
      tracked.


      Guidelines:

      - Group related tasks under ## numbered headings

      - Each task MUST be a checkbox: `- [ ] X.Y Task description`

      - Tasks should be small enough to complete in one session

      - Order tasks by dependency (what must be done first?)


      Example:

      ```

      ## 1. Setup


      - [ ] 1.1 Create new module structure

      - [ ] 1.2 Add dependencies to package.json


      ## 2. Core Implementation


      - [ ] 2.1 Implement data export function

      - [ ] 2.2 Add CSV formatting utilities

      ```


      Reference specs for what needs to be built, design for how to build it.

      Each task should be verifiable - you know when it's done.
    requires:
      - specs
      - design
apply:
  requires:
    - tasks
  tracks: tasks.md
  instruction: |
    Read context files, work through pending tasks, mark complete as you go.
    Pause if you hit blockers or need clarification.
